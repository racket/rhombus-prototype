#lang rhombus


export:
  RegularImmutableList


import:
  rhombus/data/private/list.List
  rhombus/data/private/persistent_list.PersistentList
  rhombus/data/sequence.Iterator
  lib("racket/base.rkt").error


class RegularImmutableList(storage :: Array):
  implements List
  internal PrivateRegularImmutableList

  override method iterate(): ImmutableListIterator(this)
  override property size: storage.length()
  override method isEmpty(): #false

  override method get(index):
    checkIndex("List.get", index)
    storage[index]

  override method sublist(start, end):
    checkSublistIndicies("List.sublist", start, end)
    RegularImmutableSublist(this, start, end)

  override method add(element): toPersistent().add(element)
  override method remove(element): toPersistent().remove(element)

  override method set(index, element):
    checkIndex("List.set", index)
    toPersistent().set(index, element)

  override method insert(index, element):
    checkInsertionIndex("List.insert", index)
    toPersistent().insert(index, element)

  override method delete(index):
    checkIndex("List.delete", index)
    toPersistent().delete(index)

  private method toPersistent(): PersistentList().addAll(this)


class RegularImmutableSublist(
  backingList :: PrivateRegularImmutableList, start :: Integer, end :: Integer):

  implements List

  override method iterate(): ImmutableListIterator(this)
  override property size: end - start
  override method isEmpty(): start < end

  override method get(index):
    checkIndex("List.get", index)
    backingList.storage[start + index]

  override method sublist(start, end):
    checkSublistIndicies("List.sublist", start, end)
    RegularImmutableSublist(backingList, this.start + start, this.start + end)

  override method add(element): toPersistent().add(element)
  override method remove(element): toPersistent().remove(element)

  override method set(index, element):
    checkIndex("List.set", index)
    toPersistent().set(index, element)

  override method insert(index, element):
    checkInsertionIndex("List.insert", index)
    toPersistent().insert(index, element)

  override method delete(index):
    checkIndex("List.delete", index)
    toPersistent().delete(index)

  private method toPersistent(): PersistentList().addAll(this)


class ImmutableListIterator(backingList :: List):
  implements Iterator

  private field index :: Integer: 0

  override method hasNext(): index < backingList.size

  override method next():
    unless index < backingList.size | error("no such element")
    let element = backingList.get(index)
    index := index + 1
    element
